# Cybersecurity Vulnerability Viewer

## Description

This web application is a simple, efficient, and responsive solution for users to view and search vulnerabilities in the **National Vulnerability Database** (NVD). Built with **TypeScript** and **React**, it leverages the NVD REST API to fetch vulnerability data. Vite serves as the development server and build tool, ensuring a streamlined development experience.

To optimize performance, the application employs **Axios** and **React Query** for API calls. React Query's query caching feature enhances efficiency by storing and retrieving API responses. The cache is automatically cleared every 30 minutes to keep the data up to date and minimize strain on the NVD servers.

Smooth navigation is facilitated by **React Router v6**, which handles routing within the application. The user interface, designed with **Material UI**, delivers an appealing and intuitive experience. Moreover, the application supports both dark and light modes, providing flexibility to cater to user preferences. Its responsive design ensures seamless usage across various devices and screen sizes.

## Installation

1. Clone the repository
   ```bash
    git clone git@github.com:Imaginaryverse/cybersecurity-vulnerability-viewer.git
   ```
2. Install dependencies
   ```bash
     yarn
   ```
3. Start the development server
   ```bash
     yarn dev
   ```
4. Open [http://localhost:5173](http://localhost:5173) with your browser to see the result.

## Usage

### Home

Upon starting the application, the user is navigated to the home page. A brief introduction to the application is displayed and the latest database entries from the last 48 hours are fetched from the API.

Results are displayed in a list (50 per page) with each items displaying the ID, base score, description, modified date and published date, as well as the source identifier. The user also has the option to sort the results (publish date in descending order per default). Clicking the "VIEW" button navigates the user to the vulnerability details page.

### Vulnerability Search

On the `/vulnerability/search` page, the user can search for vulnerabilities based on a keyword (searching is disabled until the user enters at least 3 alphanumeric characters to prevent excessive API calls). The user also has the option to select a time period to filter the results. The maximum time period is 120 days as per the API documentation.

Results are displayed using the same list component and can be sorted as on the home page. Results are sorted by CVE ID per default. Clicking the "VIEW" button navigates the user to the vulnerability details page.

### Vulnerability Details

On the `/vulnerability/:id` page, the user can view the details of a vulnerability. While the vulnerability ID is passed as a parameter in the URL, the vulnerability object itself is passed
as a prop from the `/vulnerability/search` page using React Router's `location.state` object. This is to prevent excessive API calls. If the user navigates to the `/vulnerability/:id` page directly, the vulnerability object is fetched from the API.

The vulnerability details page displays a summary of the vulnerability, base score, impact scores, vectors, configurations, weaknesses and references. The references are displayed as a list of links, which the user can click to open in a new tab. Some vulnerabilties may not have all the information listed above, in which case the corresponding section is not displayed.

## Testing

Run the following command to run the tests:

```bash
  yarn test
```

## Thoughts on assignment

- While storing the keyword and search results in **React Context** (as described in the assignment) would have been a viable solution, using **React Query** to cache not only the keyword but also the search results, time span and page index is a more efficient solution. This is because React Query's query caching feature is optimized for storing and retrieving API responses. Moreover, the cache is automatically cleared every 30 minutes to keep the data up to date and minimize strain on the NVD servers. One could also argue that this approach actually makes use of React Context to store the keyword and responses since React Query uses React Context under the hood. I am, however, very interested in hearing your thoughts on this and hope that me choosing not to use React Context isn't out of line. If necessary, I can implement the assignment as described. React Context is currently used to store the theme (dark or light) and toggle the theme.
- While the assignment asked for a `/vulnerability/:keyword` route, I decided to use the `/vulnerability/search` route with query parameters instead. This decision was made primarily with user experience in mind. Having a separate search page makes navigating the application more intuitive and easier for the user. The alternative would be to have a `/vulnerability` page, on which the user would input a keyword, and then be redirected to the `/vulnerability/:keyword` page where the fetching and rendering of results would take place. However, this would be less intuitive and would require more steps to achieve the same result. It would also require time span and page index to be passed as query parameters anyway, making the `/vulnerability/:keyword` route redundant. Moreover, the addition of the `/vulnerability/:id` route made it possible to pass the vulnerability object as a prop from the `/vulnerability/search` page, which is more efficient than fetching the vulnerability object from the API again.
- Parsing the API response proved to be a challenge. I initially tried to parse the entire object, creating types for each property. However, this was too time-consuming, complex and inefficient. I then decided to only parse the properties that were most relevant, and parse the vector string to key-value pairs instead. This approach was much more efficient. The API documentation lists a few expressions that rarely (if ever) appear in the vector string, such as MAV, MAC, MPR, MUI, MS, M(CIA) and so on. I decided to ignore these expressions due to their infrequency and me being uncertain of their relevance.
- While the API supports fetching results within a time span, it no longer supports sorting the results by either publish date or modified date. Such a feature would make the application more user-friendly and intuitive. As a middle ground, I decided to sort the results on the home page by publish date per default since the number of results per 48 hours is relatively small and therefore makes sorting more intuitive there. The situation is different on the search page, where the number of results can be much larger. Because the results are sorted by CVE ID per default (in ascending order), sorting the response by publish date (in descending order) makes little sense. The most efficient way to view the latest results at the moment is to navigate to the last page of the results and sort them there. This is not ideal, but it is the best solution given the circumstances.
- Using **Material UI** was an interesting experience. I tend to use **Styled Components** for most of my own projects which gives me more control over the styling and behaviour of my components. However, it does tend to take longer to get an application up and running. Material UI, on the other hand, proved to be very easy to set up and use. It also provides a lot of flexibility and customization options. I will definitely consider using it for future projects.
- I initally went with tables for displaying the results, but quickly ran into issues with responsiveness. I decided to use a list instead, which proved to be a much better solution. Tables, by simply being oriented horizontally, are not very responsive by nature. There is always the option to have them scrollable on smaller screens, but this is not very user-friendly. Using a list allowed me to pack more information into a smaller space and display it in a more intuitive manner, making it more responsive and user-friendly overall.
- There are extensive unit tests (written in **Jest**) for most of the utility methods implemented in the application. A few components also have unit tests (written in **React Testing Library**). However, due to time constraints and inexperience with RTL and MUI, I was unable to write unit tests for all components. I would have liked to write more extensive tests, but I hope that the ones I have written are sufficient for now.

## Future improvements

- Additional tests for components, hooks and utility methods.
- Project structure improvements, such as moving sx styles to a separate file. Some components already have this, but not all.
- Implement alternative version using React Context for state management.
