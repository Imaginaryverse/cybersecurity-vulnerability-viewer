import {
  serializeSearchParams,
  isValidKeyword,
  camelCaseToTitleCase,
  parseVectorString,
} from '../../utils/stringUtils';
import { VectorItem } from '../../types/CVE.types';

describe('serializeSearchParams', () => {
  describe('when given an object with a single key-value pair', () => {
    it('returns a query string', () => {
      const params = { foo: 'bar' };
      const result = serializeSearchParams(params);
      expect(result).toBe('foo=bar');
    });
  });

  describe('when given an object with multiple key-value pairs', () => {
    it('returns a query string', () => {
      const params = { foo: 'bar', baz: 'qux' };
      const result = serializeSearchParams(params);
      expect(result).toBe('foo=bar&baz=qux');
    });
  });

  describe('when given an object with a null value', () => {
    it('returns a query string', () => {
      const params = { foo: null };
      const result = serializeSearchParams(params);
      expect(result).toBe('foo=null');
    });
  });

  describe('when given an object with an undefined value', () => {
    it('returns a query string', () => {
      const params = { foo: undefined };
      const result = serializeSearchParams(params);
      expect(result).toBe('foo=undefined');
    });
  });

  describe('when given an object with a boolean value', () => {
    it('returns a query string', () => {
      const params = { foo: true };
      const result = serializeSearchParams(params);
      expect(result).toBe('foo=true');
    });
  });

  describe('when given an object with a number value', () => {
    it('returns a query string', () => {
      const params = { foo: 1 };
      const result = serializeSearchParams(params);
      expect(result).toBe('foo=1');
    });
  });

  describe('when given an empty object', () => {
    it('returns an empty string', () => {
      const params = {};
      const result = serializeSearchParams(params);
      expect(result).toBe('');
    });
  });
});

describe('isValidKeyword', () => {
  describe('when given a string with at least 3 alphanumeric characters', () => {
    it('returns true', () => {
      const result = isValidKeyword('foo');
      expect(result).toBe(true);
    });
  });

  describe('when given a string with less than 3 alphanumeric characters', () => {
    it('returns false', () => {
      const result = isValidKeyword('fo');
      expect(result).toBe(false);
    });
  });

  describe('when given a string with only non-alphanumeric characters', () => {
    it('returns false', () => {
      const result = isValidKeyword('!@#$%^&*()');
      expect(result).toBe(false);
    });
  });

  describe('when given an empty string', () => {
    it('returns false', () => {
      const result = isValidKeyword('');
      expect(result).toBe(false);
    });
  });

  describe('when given a string with only whitespace characters', () => {
    it('returns false', () => {
      const result = isValidKeyword('   ');
      expect(result).toBe(false);
    });
  });
});

describe('camelCaseToTitleCase', () => {
  describe('when given a camelCase string', () => {
    it('returns a Title Case string', () => {
      const result = camelCaseToTitleCase('fooBarBaz');
      expect(result).toBe('Foo Bar Baz');
    });
  });

  describe('when given a camelCase string with numbers', () => {
    it('returns a Title Case string', () => {
      const result = camelCaseToTitleCase('foo2Bar3Baz4');
      expect(result).toBe('Foo 2 Bar 3 Baz 4');
    });
  });

  describe('when given a string with no camelCase characters', () => {
    it('returns the original string', () => {
      const result = camelCaseToTitleCase('foo bar baz');
      expect(result).toBe('Foo bar baz');
    });
  });
});

describe('parseVectorString', () => {
  const vectorString = 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H';
  const vectorArray: VectorItem[] = [
    {
      name: 'Attack Vector',
      value: 'Network',
    },
    {
      name: 'Attack Complexity',
      value: 'Low',
    },
    {
      name: 'Privileges Required',
      value: 'None',
    },
    {
      name: 'User Interaction',
      value: 'None',
    },
    {
      name: 'Scope',
      value: 'Unchanged',
    },
    {
      name: 'Confidentiality Impact',
      value: 'None',
    },
    {
      name: 'Integrity Impact',
      value: 'None',
    },
    {
      name: 'Availability Impact',
      value: 'High',
    },
  ];

  describe('when given a valid vector string', () => {
    it('returns an array of vector items', () => {
      const result = parseVectorString(vectorString);
      expect(result).toEqual(vectorArray);
    });
  });

  describe('when given an invalid vector string', () => {
    it('returns an empty array', () => {
      const result = parseVectorString('foo');
      expect(result).toEqual([]);
    });
  });
});
