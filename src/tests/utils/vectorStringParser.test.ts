import { parseVectorString } from '../../utils/vectorStringParser';

describe('parseVectorStringV2 - CVSS v2', () => {
  describe('when given key "AV"', () => {
    const str = 'AV:N/AV:A/AV:L';
    const result = parseVectorString(str, '2.0');
    it('returns name ("Access Vector") and correct values', () => {
      expect(result).toEqual([
        { name: 'Access Vector', value: 'Network' },
        { name: 'Access Vector', value: 'Adjacent Network' },
        { name: 'Access Vector', value: 'Local' },
      ]);
    });
  });

  describe('when given key "AC"', () => {
    const str = 'AC:L/AC:M/AC:H';
    const result = parseVectorString(str, '2.0');
    it('returns name ("Access Complexity") and correct values', () => {
      expect(result).toEqual([
        { name: 'Access Complexity', value: 'Low' },
        { name: 'Access Complexity', value: 'Medium' },
        { name: 'Access Complexity', value: 'High' },
      ]);
    });
  });

  describe('when given key "Au"', () => {
    const str = 'Au:N/Au:S/Au:M';
    const result = parseVectorString(str, '2.0');
    it('returns name ("Authentication") and correct values', () => {
      expect(result).toEqual([
        { name: 'Authentication', value: 'None' },
        { name: 'Authentication', value: 'Single' },
        { name: 'Authentication', value: 'Multiple' },
      ]);
    });
  });

  describe('when given key "C"', () => {
    const str = 'C:N/C:L/C:H/C:P/C:C';
    const result = parseVectorString(str, '2.0');
    it('returns name ("Confidentiality Impact") and correct values', () => {
      expect(result).toEqual([
        { name: 'Confidentiality Impact', value: 'None' },
        { name: 'Confidentiality Impact', value: 'Low' },
        { name: 'Confidentiality Impact', value: 'High' },
        { name: 'Confidentiality Impact', value: 'Partial' },
        { name: 'Confidentiality Impact', value: 'Complete' },
      ]);
    });
  });

  describe('when given key "I"', () => {
    const str = 'I:N/I:L/I:H/I:P/I:C';
    const result = parseVectorString(str, '2.0');
    it('returns name ("Integrity Impact") and correct values', () => {
      expect(result).toEqual([
        { name: 'Integrity Impact', value: 'None' },
        { name: 'Integrity Impact', value: 'Low' },
        { name: 'Integrity Impact', value: 'High' },
        { name: 'Integrity Impact', value: 'Partial' },
        { name: 'Integrity Impact', value: 'Complete' },
      ]);
    });
  });

  describe('when given key "A"', () => {
    const str = 'A:N/A:L/A:H/A:P/A:C';
    const result = parseVectorString(str, '2.0');
    it('returns name ("Availability Impact") and correct values', () => {
      expect(result).toEqual([
        { name: 'Availability Impact', value: 'None' },
        { name: 'Availability Impact', value: 'Low' },
        { name: 'Availability Impact', value: 'High' },
        { name: 'Availability Impact', value: 'Partial' },
        { name: 'Availability Impact', value: 'Complete' },
      ]);
    });
  });

  describe('when given key "E"', () => {
    const str = 'E:ND/E:U/E:POC/E:F/E:H';
    const result = parseVectorString(str, '2.0');
    it('returns name ("Exploitability") and correct values', () => {
      expect(result).toEqual([
        { name: 'Exploitability', value: 'Not Defined' },
        { name: 'Exploitability', value: 'Unproven' },
        { name: 'Exploitability', value: 'Proof-of-Concept' },
        { name: 'Exploitability', value: 'Functional' },
        { name: 'Exploitability', value: 'High' },
      ]);
    });
  });

  describe('when given key "RL"', () => {
    const str = 'RL:ND/RL:OF/RL:TF/RL:W/RL:U';
    const result = parseVectorString(str, '2.0');
    it('returns name ("Remediation Level") and correct values', () => {
      expect(result).toEqual([
        { name: 'Remediation Level', value: 'Not Defined' },
        { name: 'Remediation Level', value: 'Official Fix' },
        { name: 'Remediation Level', value: 'Temporary Fix' },
        { name: 'Remediation Level', value: 'Workaround' },
        { name: 'Remediation Level', value: 'Unavailable' },
      ]);
    });
  });

  describe('when given key "RC"', () => {
    const str = 'RC:ND/RC:UC/RC:UR/RC:C';
    const result = parseVectorString(str, '2.0');
    it('returns name ("Report Confidence") and correct values', () => {
      expect(result).toEqual([
        { name: 'Report Confidence', value: 'Not Defined' },
        { name: 'Report Confidence', value: 'Unconfirmed' },
        { name: 'Report Confidence', value: 'Uncorroborated' },
        { name: 'Report Confidence', value: 'Confirmed' },
      ]);
    });
  });
});

describe('parseVectorStringV2 - CVSS v3', () => {
  describe('when given key "AV"', () => {
    const str = 'AV:N/AV:A/AV:L/AV:P';
    const result = parseVectorString(str, '3.0');
    it('returns name ("Attack Vector") and correct values', () => {
      expect(result).toEqual([
        { name: 'Attack Vector', value: 'Network' },
        { name: 'Attack Vector', value: 'Adjacent Network' },
        { name: 'Attack Vector', value: 'Local' },
        { name: 'Attack Vector', value: 'Physical' },
      ]);
    });
  });

  describe('when given key "AC"', () => {
    const str = 'AC:L/AC:H';
    const result = parseVectorString(str, '3.0');
    it('returns name ("Attack Complexity") and correct values', () => {
      expect(result).toEqual([
        { name: 'Attack Complexity', value: 'Low' },
        { name: 'Attack Complexity', value: 'High' },
      ]);
    });
  });

  describe('when given key "PR"', () => {
    const str = 'PR:N/PR:L/PR:H';
    const result = parseVectorString(str, '3.0');
    it('returns name ("Privileges Required") and correct values', () => {
      expect(result).toEqual([
        { name: 'Privileges Required', value: 'None' },
        { name: 'Privileges Required', value: 'Low' },
        { name: 'Privileges Required', value: 'High' },
      ]);
    });
  });

  describe('when given key "UI"', () => {
    const str = 'UI:N/UI:R';
    const result = parseVectorString(str, '3.0');
    it('returns name ("User Interaction") and correct values', () => {
      expect(result).toEqual([
        { name: 'User Interaction', value: 'None' },
        { name: 'User Interaction', value: 'Required' },
      ]);
    });
  });

  describe('when given key "S"', () => {
    const str = 'S:U/S:C';
    const result = parseVectorString(str, '3.0');
    it('returns name ("Scope") and correct values', () => {
      expect(result).toEqual([
        { name: 'Scope', value: 'Unchanged' },
        { name: 'Scope', value: 'Changed' },
      ]);
    });
  });

  describe('when given key "C"', () => {
    const str = 'C:N/C:L/C:H';
    const result = parseVectorString(str, '3.0');
    it('returns name ("Confidentiality Impact") and correct values', () => {
      expect(result).toEqual([
        { name: 'Confidentiality Impact', value: 'None' },
        { name: 'Confidentiality Impact', value: 'Low' },
        { name: 'Confidentiality Impact', value: 'High' },
      ]);
    });
  });

  describe('when given key "I"', () => {
    const str = 'I:N/I:L/I:H';
    const result = parseVectorString(str, '3.0');
    it('returns name ("Integrity Impact") and correct values', () => {
      expect(result).toEqual([
        { name: 'Integrity Impact', value: 'None' },
        { name: 'Integrity Impact', value: 'Low' },
        { name: 'Integrity Impact', value: 'High' },
      ]);
    });
  });

  describe('when given key "A"', () => {
    const str = 'A:N/A:L/A:H';
    const result = parseVectorString(str, '3.0');
    it('returns name ("Availability Impact") and correct values', () => {
      expect(result).toEqual([
        { name: 'Availability Impact', value: 'None' },
        { name: 'Availability Impact', value: 'Low' },
        { name: 'Availability Impact', value: 'High' },
      ]);
    });
  });

  describe('when given key "E"', () => {
    const str = 'E:X/E:U/E:P/E:F/E:H';
    const result = parseVectorString(str, '3.0');
    it('returns name ("Exploit Code Maturity") and correct values', () => {
      expect(result).toEqual([
        { name: 'Exploit Code Maturity', value: 'Not Defined' },
        { name: 'Exploit Code Maturity', value: 'Unproven' },
        { name: 'Exploit Code Maturity', value: 'Proof-of-Concept' },
        { name: 'Exploit Code Maturity', value: 'Functional' },
        { name: 'Exploit Code Maturity', value: 'High' },
      ]);
    });
  });

  describe('when given key "RL"', () => {
    const str = 'RL:X/RL:O/RL:T/RL:W/RL:U';
    const result = parseVectorString(str, '3.0');
    it('returns name ("Remediation Level") and correct values', () => {
      expect(result).toEqual([
        { name: 'Remediation Level', value: 'Not Defined' },
        { name: 'Remediation Level', value: 'Official Fix' },
        { name: 'Remediation Level', value: 'Temporary Fix' },
        { name: 'Remediation Level', value: 'Workaround' },
        { name: 'Remediation Level', value: 'Unavailable' },
      ]);
    });
  });

  describe('when given key "RC"', () => {
    const str = 'RC:X/RC:U/RC:R/RC:C';
    const result = parseVectorString(str, '3.0');
    it('returns name ("Report Confidence") and correct values', () => {
      expect(result).toEqual([
        { name: 'Report Confidence', value: 'Not Defined' },
        { name: 'Report Confidence', value: 'Unknown' },
        { name: 'Report Confidence', value: 'Reasonable' },
        { name: 'Report Confidence', value: 'Confirmed' },
      ]);
    });
  });
});
