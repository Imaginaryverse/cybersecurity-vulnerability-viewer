import {
  ApiResponse,
  CVE,
  ParsedApiResponse,
  ParsedCve,
  ParsedMetrics,
} from '../types/CVE.types';
import { SeverityType } from '../types/CVSS.enums';
import { parseVectorString } from './stringUtils';

function parseMetrics(metrics: CVE['metrics']): ParsedMetrics | undefined {
  const versionKeys = Object.keys(metrics) as Array<keyof typeof metrics>;

  if (!metrics || !versionKeys.length) {
    return undefined;
  }

  if (
    versionKeys.includes('cvssMetricV31') ||
    versionKeys.includes('cvssMetricV3')
  ) {
    const data = metrics.cvssMetricV31?.[0] ?? metrics.cvssMetricV3?.[0];

    if (!data) {
      return undefined;
    }

    const parsed: ParsedMetrics = {
      // BASE
      version: data.cvssData.version,
      type: data.type,
      vectorString: data.cvssData.vectorString,
      baseSeverity: data.cvssData.baseSeverity ?? SeverityType.NOT_DEFINED,

      vectors: parseVectorString(data.cvssData.vectorString),

      // SCORES
      scores: {
        baseScore: data.cvssData.baseScore,
        temporalScore: data.cvssData.temporalScore ?? 0,
        environmentalScore: data.cvssData.environmentalScore ?? 0,
        exploitabilityScore: data.exploitabilityScore ?? 0,
        impactScore: data.impactScore ?? 0,
      },
    };

    return parsed;
  }

  const data = metrics.cvssMetricV2?.[0];

  if (!data) {
    return undefined;
  }

  const parsed: ParsedMetrics = {
    // BASE
    version: data.cvssData.version,
    type: data.type,
    vectorString: data.cvssData.vectorString,
    baseSeverity: data.baseSeverity ?? SeverityType.NOT_DEFINED,

    vectors: parseVectorString(data.cvssData.vectorString),

    // SCORES
    scores: {
      baseScore: data.cvssData.baseScore,
      temporalScore: data.cvssData.temporalScore ?? 0,
      environmentalScore: data.cvssData.environmentalScore ?? 0,
      exploitabilityScore: data.exploitabilityScore ?? 0,
      impactScore: data.impactScore ?? 0,
    },
  };

  return parsed;
}

export function parseCve(cve: CVE): ParsedCve {
  const parsed: ParsedCve = {
    id: cve.id,
    lastModified: cve.lastModified,
    published: cve.published,
    description:
      cve.descriptions.find(d => d.lang === 'en')?.value || 'Not available',
    references: cve.references,
    sourceIdentifier: cve.sourceIdentifier,
    vulnStatus: cve.vulnStatus,
    metrics: parseMetrics(cve.metrics),
    weaknesses: cve.weaknesses.map(w => ({
      description:
        w.description.find(d => d.lang === 'en')?.value ||
        'Description not available',
      source: w.source,
      type: w.type,
    })),
    configurations: cve.configurations.map(conf => ({
      operator: conf.nodes[0].operator,
      negate: conf.nodes[0].negate,
      cpeMatch: {
        criteria: conf.nodes[0].cpeMatch[0].criteria,
        matchCriteriaId: conf.nodes[0].cpeMatch[0].matchCriteriaId,
        vulnerable: conf.nodes[0].cpeMatch[0].vulnerable,
      },
    })),
  };

  return parsed;
}

export function parseApiResponse(
  res: ApiResponse,
  sortOptions?: {
    sortBy: 'published' | 'last-modified';
    sortOrder: 'asc' | 'desc';
  }
): ParsedApiResponse {
  const parsedCves = res.vulnerabilities.map(v => parseCve(v.cve));

  const parsedResponse: ParsedApiResponse = {
    format: res.format,
    resultsPerPage: res.resultsPerPage,
    maxPage: Math.ceil(res.totalResults / res.resultsPerPage),
    startIndex: res.startIndex,
    totalResults: res.totalResults,
    timestamp: res.timestamp,
    version: res.version,
    cves: sortOptions
      ? parsedCves.sort((a, b) => {
          if (sortOptions.sortBy === 'published') {
            return sortOptions.sortOrder === 'asc'
              ? new Date(a.published).getTime() -
                  new Date(b.published).getTime()
              : new Date(b.published).getTime() -
                  new Date(a.published).getTime();
          }

          return sortOptions.sortOrder === 'asc'
            ? new Date(a.lastModified).getTime() -
                new Date(b.lastModified).getTime()
            : new Date(b.lastModified).getTime() -
                new Date(a.lastModified).getTime();
        })
      : parsedCves,
  };

  return parsedResponse;
}
