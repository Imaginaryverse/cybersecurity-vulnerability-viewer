import {
  ApiResponse,
  CVE,
  ParsedApiResponse,
  ParsedCve,
} from '../types/CVE.types';
import {
  AttackComplexityType,
  AttackVectorType,
  CiaType,
  ExploitCodeMaturityType,
  ReportConfidenceType,
  SeverityType,
} from '../types/CVSS.enums';

function parseRawCvssData(data: object): ParsedCve['metrics'] {
  const keys = Object.keys(data) as Array<keyof typeof data>;

  const cvssData: ParsedCve['metrics'] = {
    version: '',
    vectorString: '',
    baseSeverity: SeverityType.NOT_DEFINED,
    baseScore: 0,
    temporalScore: 0,
    environmentScore: 0,
    attackVector: AttackVectorType.NOT_DEFINED,
    attackComplexity: AttackComplexityType.NOT_DEFINED,
    confidentialityImpact: CiaType.NOT_DEFINED,
    integrityImpact: CiaType.NOT_DEFINED,
    availabilityImpact: CiaType.NOT_DEFINED,
    exploitCodeMaturity: ExploitCodeMaturityType.NOT_DEFINED,
    reportConfidence: ReportConfidenceType.NOT_DEFINED,
  };

  keys.forEach(key => {
    switch (key) {
      case 'version':
        cvssData.version = data[key];
        break;
      case 'vectorString':
        cvssData.vectorString = data[key];
        break;
      case 'baseSeverity':
        cvssData.baseSeverity = data[key];
        break;
      case 'baseScore':
        cvssData.baseScore = data[key];
        break;
      case 'temporalScore':
        cvssData.temporalScore = data[key];
        break;
      case 'environmentScore':
        cvssData.environmentScore = data[key];
        break;
      case 'attackVector':
      case 'accessVector':
        cvssData.attackVector = data[key];
        break;
      case 'attackComplexity':
      case 'accessComplexity':
        cvssData.attackComplexity = data[key];
        break;
      case 'confidentialityImpact':
        cvssData.confidentialityImpact = data[key];
        break;
      case 'integrityImpact':
        cvssData.integrityImpact = data[key];
        break;
      case 'availabilityImpact':
        cvssData.availabilityImpact = data[key];
        break;
      case 'exploitCodeMaturity':
      case 'exploitability':
        cvssData.exploitCodeMaturity = data[key];
        break;
      case 'reportConfidence':
        cvssData.reportConfidence = data[key];
        break;
      default:
        break;
    }
  });

  return cvssData;
}

export function parseCve(cve: CVE): ParsedCve {
  const parsed: ParsedCve = {
    id: cve.id,
    lastModified: cve.lastModified,
    published: cve.published,
    description:
      cve.descriptions.find(d => d.lang === 'en')?.value || 'Not available',
    references: cve.references,
    sourceIdentifier: cve.sourceIdentifier,
    vulnStatus: cve.vulnStatus,
    metrics: undefined,
    weaknesses: cve.weaknesses,
  };

  if (cve.metrics?.cvssMetricV31) {
    parsed.metrics = parseRawCvssData(cve.metrics.cvssMetricV31[0].cvssData);
  } else if (cve.metrics?.cvssMetricV3) {
    parsed.metrics = parseRawCvssData(cve.metrics.cvssMetricV3[0].cvssData);
  } else if (cve.metrics?.cvssMetricV2) {
    parsed.metrics = parseRawCvssData(cve.metrics.cvssMetricV2[0].cvssData);
  }

  return parsed;
}

export function parseApiResponse(res: ApiResponse): ParsedApiResponse {
  const parsed: ParsedApiResponse = {
    format: res.format,
    resultsPerPage: res.resultsPerPage,
    maxPage: Math.ceil(res.totalResults / res.resultsPerPage),
    startIndex: res.startIndex,
    totalResults: res.totalResults,
    timestamp: res.timestamp,
    version: res.version,
    cves: res.vulnerabilities.map(v => parseCve(v.cve)),
  };

  return parsed;
}
