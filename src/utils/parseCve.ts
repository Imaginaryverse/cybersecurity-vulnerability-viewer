import {
  ApiResponse,
  CVE,
  ParsedApiResponse,
  ParsedCve,
  ParsedMetrics,
} from '../types/CVE.types';
import { SeverityType } from '../types/CVSS.enums';
import { parseVectorString } from './stringUtils';

type ApiResponseSortOptions = {
  sortBy: 'published' | 'last-modified';
  sortOrder: 'asc' | 'desc';
};

function parseMetrics(metrics: CVE['metrics']): ParsedMetrics | undefined {
  const versionKeys = Object.keys(metrics) as Array<keyof typeof metrics>;

  if (!metrics || !versionKeys.length) {
    return undefined;
  }

  if (
    versionKeys.includes('cvssMetricV31') ||
    versionKeys.includes('cvssMetricV3')
  ) {
    const data = metrics.cvssMetricV31?.[0] ?? metrics.cvssMetricV3?.[0];

    if (!data) {
      return undefined;
    }

    const parsed: ParsedMetrics = {
      // BASE
      version: data.cvssData.version,
      type: data.type,
      vectorString: data.cvssData.vectorString,
      baseScore: data.cvssData.baseScore,
      baseSeverity: data.cvssData.baseSeverity ?? SeverityType.NOT_DEFINED,

      vectors: parseVectorString(data.cvssData.vectorString),

      // SCORES
      scores: {
        temporalScore: data.cvssData.temporalScore ?? 0,
        environmentalScore: data.cvssData.environmentalScore ?? 0,
        exploitabilityScore: data.exploitabilityScore ?? 0,
        impactScore: data.impactScore ?? 0,
      },
    };

    return parsed;
  }

  const data = metrics.cvssMetricV2?.[0];

  if (!data) {
    return undefined;
  }

  const parsed: ParsedMetrics = {
    // BASE
    version: data.cvssData.version,
    type: data.type,
    vectorString: data.cvssData.vectorString,
    baseScore: data.cvssData.baseScore,
    baseSeverity: data.baseSeverity ?? SeverityType.NOT_DEFINED,

    vectors: parseVectorString(data.cvssData.vectorString),

    // SCORES
    scores: {
      temporalScore: data.cvssData.temporalScore ?? 0,
      environmentalScore: data.cvssData.environmentalScore ?? 0,
      exploitabilityScore: data.exploitabilityScore ?? 0,
      impactScore: data.impactScore ?? 0,
    },
  };

  return parsed;
}

const parseWeaknesses = (
  weaknesses: CVE['weaknesses']
): ParsedCve['weaknesses'] => {
  if (!weaknesses?.length) {
    return [];
  }

  return weaknesses.map(w => ({
    description:
      w.description.find(d => d.lang === 'en')?.value ||
      'Description not available',
    source: w.source,
    type: w.type,
  }));
};

const parseConfigurations = (
  configurations: CVE['configurations']
): ParsedCve['configurations'] => {
  if (!configurations?.length) {
    return [];
  }

  return configurations.map(conf => ({
    operator: conf.nodes[0].operator,
    negate: conf.nodes[0].negate,
    cpeMatch: {
      criteria: conf.nodes[0].cpeMatch[0].criteria,
      matchCriteriaId: conf.nodes[0].cpeMatch[0].matchCriteriaId,
      vulnerable: conf.nodes[0].cpeMatch[0].vulnerable,
    },
  }));
};

export function parseCve(cve: CVE): ParsedCve {
  const parsed: ParsedCve = {
    id: cve.id,
    lastModified: cve.lastModified,
    published: cve.published,
    description:
      cve.descriptions.find(d => d.lang === 'en')?.value || 'Not available',
    references: cve.references,
    sourceIdentifier: cve.sourceIdentifier,
    vulnStatus: cve.vulnStatus,
    metrics: parseMetrics(cve.metrics),
    weaknesses: parseWeaknesses(cve.weaknesses),
    configurations: parseConfigurations(cve.configurations),
  };

  return parsed;
}

function sortCvesByPublished(a: ParsedCve, b: ParsedCve) {
  return new Date(a.published).getTime() - new Date(b.published).getTime();
}

function sortCvesByLastModified(a: ParsedCve, b: ParsedCve) {
  return (
    new Date(a.lastModified).getTime() - new Date(b.lastModified).getTime()
  );
}

function sortCves(cves: ParsedCve[], sortOptions: ApiResponseSortOptions) {
  return cves.sort((a, b) => {
    if (sortOptions.sortBy === 'published') {
      return sortOptions.sortOrder === 'asc'
        ? sortCvesByPublished(a, b)
        : sortCvesByPublished(b, a);
    }

    return sortOptions.sortOrder === 'asc'
      ? sortCvesByLastModified(a, b)
      : sortCvesByLastModified(b, a);
  });
}

export function parseApiResponse(
  res: ApiResponse,
  sortOptions?: ApiResponseSortOptions
): ParsedApiResponse {
  const parsedCves = res.vulnerabilities.map(v => parseCve(v.cve));

  const parsedResponse: ParsedApiResponse = {
    format: res.format,
    resultsPerPage: res.resultsPerPage,
    maxPage: Math.ceil(res.totalResults / res.resultsPerPage),
    startIndex: res.startIndex,
    totalResults: res.totalResults,
    timestamp: res.timestamp,
    version: res.version,

    cves: sortOptions
      ? sortCves(parsedCves, sortOptions)
      : parsedCves.sort(sortCvesByPublished),
  };

  return parsedResponse;
}
