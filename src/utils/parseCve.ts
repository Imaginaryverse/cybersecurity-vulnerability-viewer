import {
  ApiResponse,
  CVE,
  ParsedApiResponse,
  ParsedCve,
  ParsedMetric,
} from '../types/CVE.types';
import { CvssDataV2 } from '../types/CVSS_Data_V2.types';
import { CvssDataV3 } from '../types/CVSS_Data_V3.types';

function parseV2CvssData(cvssData: CvssDataV2): ParsedMetric {
  const parsedMetric: ParsedMetric = {
    version: cvssData.version,
    vectorString: cvssData.vectorString,
    baseScore: cvssData.baseScore,
    baseSeverity: 'N/A',
    properties: {},
  };

  for (const key in cvssData) {
    if (['version', 'vectorString', 'baseScore'].includes(key)) {
      continue;
    }

    parsedMetric.properties[key] = cvssData[key as keyof CvssDataV2];
  }

  return parsedMetric;
}

function parseV3CvssData(cvssData: CvssDataV3): ParsedMetric {
  const parsedMetric: ParsedMetric = {
    version: cvssData.version,
    vectorString: cvssData.vectorString,
    baseScore: cvssData.baseScore,
    baseSeverity: cvssData.baseSeverity,
    properties: {},
  };

  for (const key in cvssData) {
    if (
      ['version', 'vectorString', 'baseScore', 'baseSeverity'].includes(key)
    ) {
      continue;
    }

    parsedMetric.properties[key] = cvssData[key as keyof CvssDataV3];
  }

  return parsedMetric;
}

export function parseCve(cve: CVE): ParsedCve {
  const parsed: ParsedCve = {
    id: cve.id,
    lastModified: cve.lastModified,
    published: cve.published,
    descriptions: cve.descriptions,
    references: cve.references,
    sourceIdentifier: cve.sourceIdentifier,
    vulnStatus: cve.vulnStatus,
    metrics: [],
    weaknesses: cve.weaknesses,
  };

  if (cve.metrics) {
    if (cve.metrics?.cvssMetricV2) {
      parsed.metrics = cve.metrics.cvssMetricV2.map(metric =>
        parseV2CvssData(metric.cvssData)
      );
    }

    if (cve.metrics?.cvssMetricV3) {
      parsed.metrics = cve.metrics.cvssMetricV3.map(metric =>
        parseV3CvssData(metric.cvssData)
      );
    }

    if (cve.metrics?.cvssMetricV31) {
      parsed.metrics = cve.metrics.cvssMetricV31.map(metric =>
        parseV3CvssData(metric.cvssData)
      );
    }
  }

  return parsed;
}

export function parseApiResponse(res: ApiResponse): ParsedApiResponse {
  const parsed: ParsedApiResponse = {
    format: res.format,
    resultsPerPage: res.resultsPerPage,
    maxPage: Math.ceil(res.totalResults / res.resultsPerPage),
    startIndex: res.startIndex,
    totalResults: res.totalResults,
    timestamp: res.timestamp,
    version: res.version,
    cves: res.vulnerabilities.map(v => parseCve(v.cve)),
  };

  return parsed;
}
