import {
  ApiResponse,
  CVE,
  CveConfiguration,
  CveWeakness,
  ParsedApiResponse,
  ParsedCve,
  ParsedMetrics,
  ParsedNode,
  ParsedWeakness,
} from '../types/CVE.types';
import { SeverityType } from '../types/CVSS.enums';
import { parseVectorString } from './stringUtils';

type ApiResponseSortOptions = {
  sortBy: 'published' | 'last-modified';
  sortOrder: 'asc' | 'desc';
};

export function parseMetrics(
  metrics: CVE['metrics']
): ParsedMetrics | undefined {
  const versionKeys = Object.keys(metrics) as Array<keyof typeof metrics>;

  if (!metrics || !versionKeys.length) {
    return undefined;
  }

  if (
    versionKeys.includes('cvssMetricV31') ||
    versionKeys.includes('cvssMetricV3')
  ) {
    const data = metrics.cvssMetricV31?.[0] ?? metrics.cvssMetricV3?.[0];

    if (!data) {
      return undefined;
    }

    const parsed: ParsedMetrics = {
      // BASE
      version: data.cvssData.version,
      type: data.type,
      vectorString: data.cvssData.vectorString,
      baseScore: data.cvssData.baseScore,
      baseSeverity: data.cvssData.baseSeverity ?? SeverityType.NOT_DEFINED,

      vectors: parseVectorString(data.cvssData.vectorString),

      // SCORES
      scores: {
        temporalScore: data.cvssData.temporalScore ?? 0,
        environmentalScore: data.cvssData.environmentalScore ?? 0,
        exploitabilityScore: data.exploitabilityScore ?? 0,
        impactScore: data.impactScore ?? 0,
      },
    };

    return parsed;
  }

  const data = metrics.cvssMetricV2?.[0];

  if (!data) {
    return undefined;
  }

  const parsed: ParsedMetrics = {
    // BASE
    version: data.cvssData.version,
    type: data.type,
    vectorString: data.cvssData.vectorString,
    baseScore: data.cvssData.baseScore,
    baseSeverity: data.baseSeverity ?? SeverityType.NOT_DEFINED,

    vectors: parseVectorString(data.cvssData.vectorString),

    // SCORES
    scores: {
      temporalScore: data.cvssData.temporalScore ?? 0,
      environmentalScore: data.cvssData.environmentalScore ?? 0,
      exploitabilityScore: data.exploitabilityScore ?? 0,
      impactScore: data.impactScore ?? 0,
    },
  };

  return parsed;
}

export function parseWeakness(
  weakness: CveWeakness
): ParsedWeakness | undefined {
  if (!weakness || !weakness.type || !weakness.source) {
    return undefined;
  }

  const parsed: ParsedWeakness = {
    description:
      weakness.description.find(d => d.lang === 'en')?.value ||
      'Description not available',
    source: weakness.source,
    type: weakness.type,
  };

  return parsed;
}

function parseWeaknesses(
  weaknesses: CVE['weaknesses']
): ParsedCve['weaknesses'] {
  if (!weaknesses?.length) {
    return [];
  }

  const parsed = weaknesses.map(w => parseWeakness(w));

  return parsed.filter(w => !!w) as ParsedWeakness[];
}

export function parseConfiguration(
  configuration: CveConfiguration
): ParsedNode | undefined {
  if (!configuration || !configuration.nodes?.length) {
    return undefined;
  }

  const parsed: ParsedNode = {
    operator: configuration.nodes[0].operator ?? 'N/A',
    negate: configuration.nodes[0].negate ?? false,
    cpeMatch: {
      criteria: configuration.nodes[0].cpeMatch?.[0]?.criteria ?? 'N/A',
      matchCriteriaId:
        configuration.nodes[0].cpeMatch?.[0]?.matchCriteriaId ?? 'N/A',
      vulnerable: configuration.nodes[0].cpeMatch?.[0]?.vulnerable ?? false,
    },
  };

  return parsed;
}

function parseConfigurations(
  configurations: CVE['configurations']
): ParsedCve['configurations'] {
  if (!configurations?.length) {
    return [];
  }

  const parsed = configurations.map(c => parseConfiguration(c));

  return parsed.filter(c => !!c) as ParsedNode[];
}

export function parseCve(cve: CVE): ParsedCve {
  if (!cve || !cve.id) {
    throw new Error('Invalid CVE data');
  }

  const parsed: ParsedCve = {
    id: cve.id,
    lastModified: cve.lastModified,
    published: cve.published,
    description:
      cve.descriptions.find(d => d.lang === 'en')?.value || 'Not available',
    references: cve.references,
    sourceIdentifier: cve.sourceIdentifier,
    vulnStatus: cve.vulnStatus,
    metrics: parseMetrics(cve.metrics),
    weaknesses: parseWeaknesses(cve.weaknesses),
    configurations: parseConfigurations(cve.configurations),
  };

  return parsed;
}

function sortCvesByPublished(a: ParsedCve, b: ParsedCve) {
  return new Date(a.published).getTime() - new Date(b.published).getTime();
}

function sortCvesByLastModified(a: ParsedCve, b: ParsedCve) {
  return (
    new Date(a.lastModified).getTime() - new Date(b.lastModified).getTime()
  );
}

function sortCves(cves: ParsedCve[], sortOptions: ApiResponseSortOptions) {
  return cves.sort((a, b) => {
    if (sortOptions.sortBy === 'published') {
      return sortOptions.sortOrder === 'asc'
        ? sortCvesByPublished(a, b)
        : sortCvesByPublished(b, a);
    }

    return sortOptions.sortOrder === 'asc'
      ? sortCvesByLastModified(a, b)
      : sortCvesByLastModified(b, a);
  });
}

export function parseApiResponse(
  res: ApiResponse,
  sortOptions?: ApiResponseSortOptions
): ParsedApiResponse {
  const parsedCves = res.vulnerabilities.map(v => parseCve(v.cve));

  const parsedResponse: ParsedApiResponse = {
    format: res.format,
    resultsPerPage: res.resultsPerPage,
    maxPage: Math.ceil(res.totalResults / res.resultsPerPage),
    startIndex: res.startIndex,
    totalResults: res.totalResults,
    timestamp: res.timestamp,
    version: res.version,

    cves: sortOptions
      ? sortCves(parsedCves, sortOptions)
      : parsedCves.sort(sortCvesByPublished),
  };

  return parsedResponse;
}
