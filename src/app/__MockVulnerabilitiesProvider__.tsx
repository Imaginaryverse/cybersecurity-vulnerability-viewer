/* 
  This is an example of how React Context could be used to fullfill
  the requirements of the assignment. The code below is not used in the application.

  In this example, the Context is used to store the data, keyword, and error
  state of the application. The Context is also used to fetch the data from
  the NVD API. Responses are cached to prevent unnecessary API calls.

  When the user would press the "Search" button, the keyword would be
  stored in the Context, and the data would be fetched from the API.
  If the user would navigate to another page and then return to the
  search page, the data would be fetched from the cache instead of
  the API by matching the URL parameters to the cached data.
  Also, if the user would search for the same keyword twice,
  the cached data would be returned, preventing excessive API calls.

  There are a few limitations in this example:
  - The data is not paginated. The API returns paginated data, but
    the pagination is not implemented in this example.
  - timeSpan is not implemented. The API supports filtering by time span (e.g. "pubStartDate=${startDate}&pubEndDate=${endDate}").

  Addressing the above limitations would require a more complex Context,
  particularly in terms of how to cache the data. Using the keyword as
  the key for the cache would not suffice, as the same keyword could
  be used with different time spans and/or page indexes. A more complex
  cache key would be required, e.g. a combination of keyword, time span,
  and page index.
*/

/* eslint-disable @typescript-eslint/no-empty-function */

const BASE_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';

import React, {
  FunctionComponent,
  createContext,
  useReducer,
  useCallback,
  useRef,
} from 'react';
import { ParsedApiResponse } from '../types/CVE.types';
import { serializeSearchParams } from '../utils/stringUtils';
import { parseApiResponse } from '../utils/responseParser';

type VulnerabilitiesContextType = {
  data?: ParsedApiResponse;
  keyword?: string;
  fetchData: (keyword: string) => void;
  isLoadingData: boolean;
  error: Error | null;
};

const VulnerabilitiesContext = createContext<VulnerabilitiesContextType>({
  data: undefined,
  keyword: undefined,
  fetchData: () => {},
  isLoadingData: false,
  error: null,
});

type VulnerabilitiesProviderProps = {
  children: React.ReactNode;
};

type VulnerabilitiesProviderState = {
  data?: ParsedApiResponse;
  keyword?: string;
  isLoadingData: boolean;
  error: Error | null;
};

type VulnerabilitiesProviderAction =
  | { type: 'FETCHING_DATA' }
  | { type: 'FETCHING_DATA_SUCCESS'; data: ParsedApiResponse; keyword: string }
  | { type: 'FETCHING_DATA_ERROR'; error: Error };

const initialState: VulnerabilitiesProviderState = {
  data: undefined,
  keyword: undefined,
  isLoadingData: false,
  error: null,
};

const reducer = (
  state: VulnerabilitiesProviderState,
  action: VulnerabilitiesProviderAction
): VulnerabilitiesProviderState => {
  switch (action.type) {
    case 'FETCHING_DATA':
      return { ...state, isLoadingData: true, error: null };
    case 'FETCHING_DATA_SUCCESS':
      return {
        ...state,
        data: action.data,
        keyword: action.keyword,
        isLoadingData: false,
        error: null,
      };
    case 'FETCHING_DATA_ERROR':
      return { ...state, isLoadingData: false, error: action.error };
    default:
      return state;
  }
};

export const VulnerabilitiesProvider: FunctionComponent<
  VulnerabilitiesProviderProps
> = ({ children }) => {
  const [state, dispatch] = useReducer(reducer, initialState);
  const cache = useRef<Record<string, ParsedApiResponse>>({});

  const fetchData = useCallback(async (keyword: string) => {
    if (cache.current[keyword]) {
      dispatch({
        type: 'FETCHING_DATA_SUCCESS',
        data: cache.current[keyword],
        keyword,
      });
      return;
    }

    dispatch({ type: 'FETCHING_DATA' });

    try {
      const response = await fetch(
        `${BASE_URL}?${serializeSearchParams({ keyword })}`
      );
      const data = await response.json();
      dispatch({
        type: 'FETCHING_DATA_SUCCESS',
        data: parseApiResponse(data),
        keyword,
      });
    } catch (error) {
      if (error instanceof Error) {
        dispatch({ type: 'FETCHING_DATA_ERROR', error });
      } else {
        dispatch({
          type: 'FETCHING_DATA_ERROR',
          error: new Error('Unknown error'),
        });
      }
    }
  }, []);

  return (
    <VulnerabilitiesContext.Provider
      value={{
        data: state.data,
        keyword: state.keyword,
        fetchData,
        isLoadingData: state.isLoadingData,
        error: state.error,
      }}
    >
      {children}
    </VulnerabilitiesContext.Provider>
  );
};
